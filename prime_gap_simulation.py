# -*- coding: utf-8 -*-
"""simulation_prime_random.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VlY5xosCa2BzTF1r-YQ1uvyO99DxZ3eW
"""

import sympy as sp
import numpy as np
import hashlib
from math import log2, erfc, sqrt
import matplotlib.pyplot as plt

# Core Entropy Functions

def prime_gap_entropy(n_primes=500):
    """Compute normalized entropy from the first n_primes primes."""
    primes = list(sp.primerange(2, sp.prime(n_primes)))
    gaps = np.diff(primes)
    norm_gaps = gaps / max(gaps)

    # Probability distribution
    unique, counts = np.unique(norm_gaps, return_counts=True)
    p = counts / counts.sum()
    H = -np.sum(p * np.log2(p))
    H_norm = H / log2(len(unique))
    return norm_gaps, H, H_norm


def entropy_augmented_hash(password, n_primes=500):
    """Generate hash using prime-gap–derived entropy augmentation."""
    G, H, H_norm = prime_gap_entropy(n_primes)
    G_str = ''.join(f"{x:.4f}" for x in G[:100])
    combined = (password + G_str).encode()
    hash_value = hashlib.sha256(combined).hexdigest()
    return G, H, H_norm, hash_value


# ---------- Helper: Convert hex digest to binary ----------
def hex_to_bits(hex_str):
    """Convert SHA-256 hex digest into 256-bit numpy array."""
    return np.array([int(b) for h in hex_str for b in f"{int(h,16):04b}"], dtype=int)


# ---------- Randomness Tests ----------
def monobit_frequency_test(bits):
    """
    NIST SP 800-22 Frequency (Monobit) Test.
    Returns (S_obs, p_value). Pass if p_value >= 0.01.
    """
    n = bits.size
    s = np.sum(2*bits - 1)  # convert {0,1} to {-1,+1}
    s_obs = abs(s) / sqrt(n)
    p_value = erfc(s_obs / sqrt(2.0))
    return s_obs, p_value


def chi_square_bit_balance(bits):
    """
    Chi-squared test for bit balance (df=1).
    Returns (chi2, p_value, ones_ratio).
    """
    n = bits.size
    ones = bits.sum()
    zeros = n - ones
    exp = n / 2.0
    chi2 = (zeros - exp)**2 / exp + (ones - exp)**2 / exp
    p_value = erfc(sqrt(chi2) / sqrt(2.0))
    return chi2, p_value, ones / n


# ---------- Main Program ----------
if __name__ == "__main__":
    password = input("Enter a password: ")
    n_primes = 500

    # Compute entropy and hashes
    G, H, H_norm, augmented_hash = entropy_augmented_hash(password, n_primes)
    standard_hash = hashlib.sha256(password.encode()).hexdigest()

    print("\n=== PRIME-GAP ENTROPY DEMONSTRATION ===")
    print(f"Entropy (H_p): {H:.4f} bits")
    print(f"Normalized Entropy (H_p*): {H_norm:.4f}")
    print(f"\nStandard SHA-256: {standard_hash}")
    print(f"Augmented Hash  : {augmented_hash}")

    # ---------- Visualization ----------
    plt.figure(figsize=(9, 4.5))
    plt.plot(G, marker='o', linestyle='-', linewidth=1.5, markersize=4)
    plt.title("Prime-Gap Irregularity as a Source of Mathematical Entropy", fontsize=13, pad=10)
    plt.xlabel("Index (i)", fontsize=11)
    plt.ylabel("Normalized Prime Gap (Gᵢ)", fontsize=11)
    plt.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout()
    plt.savefig("prime_gap_entropy_plot.png", dpi=300, bbox_inches="tight")
    plt.show()

    # ---------- Randomness Evaluation ----------
    bits_standard = hex_to_bits(standard_hash)
    bits_augmented = hex_to_bits(augmented_hash)

    # Monobit test
    s_std, p_std = monobit_frequency_test(bits_standard)
    s_aug, p_aug = monobit_frequency_test(bits_augmented)

    # Chi-squared test
    chi_std, p_chi_std, r_std = chi_square_bit_balance(bits_standard)
    chi_aug, p_chi_aug, r_aug = chi_square_bit_balance(bits_augmented)

    print("\n=== RANDOMNESS COMPARISON (NIST + CHI²) ===")
    print(f"Standard SHA-256:")
    print(f"  Monobit p-value     : {p_std:.4f} {'(PASS)' if p_std>=0.01 else '(FAIL)'}")
    print(f"  Chi² p-value        : {p_chi_std:.4f} {'(PASS)' if p_chi_std>=0.01 else '(FAIL)'}")
    print(f"  Ones proportion     : {r_std*100:.2f}%")

    print(f"\nPrime-Gap Augmented SHA-256:")
    print(f"  Monobit p-value     : {p_aug:.4f} {'(PASS)' if p_aug>=0.01 else '(FAIL)'}")
    print(f"  Chi² p-value        : {p_chi_aug:.4f} {'(PASS)' if p_chi_aug>=0.01 else '(FAIL)'}")
    print(f"  Ones proportion     : {r_aug*100:.2f}%")

    print("\nInterpretation:")
    print("- Both versions should have p-values >= 0.01, indicating good randomness balance.")
    print("- If the augmented version maintains similar or slightly higher p-values,")
    print("  it confirms that prime-gap entropy preserves cryptographic uniformity while")
    print("  diversifying internal entropy structure.")